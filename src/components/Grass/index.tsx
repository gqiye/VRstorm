/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { Sampler, useGLTF } from "@react-three/drei";
import { useMemo, useRef } from "react";
import { createNoise3D } from "simplex-noise";
import * as THREE from "three";
import { GLTFResult } from "../types";

import { isDesktop } from "react-device-detect";
import { GrassMaterial } from "./GrassMaterial";

export function Grass(props: JSX.IntrinsicElements["group"]) {
  const { nodes, materials } = useGLTF("/bicycle.glb") as GLTFResult;
  const { nodes: foliageNodes, materials: foliageMaterials } = useGLTF(
    "/foliage.glb"
  ) as any;

  const meshRef = useRef<THREE.Mesh>(null!);

  const noise = useMemo(() => createNoise3D(Math.random), []);
  const count = 50;

  return (
    <group {...props} dispose={null}>
      <mesh
        ref={meshRef}
        castShadow
        receiveShadow
        geometry={nodes.Circle.geometry}
        material={materials.Grass}
      />

      {isDesktop && (
        <>
          {/* Grass */}
          <Sampler
            count={count}
            transform={({ position, normal, dummy: object }) => {
              const p = position.clone().multiplyScalar(2);
              let n = noise(...p.toArray());
              n = THREE.MathUtils.smootherstep(n, 0.0, 0.7);
              object.scale.setScalar(
                THREE.MathUtils.mapLinear(n, -1, 1, 0.5, 1.5)
              );
              object.position.copy(position);
              object.rotation.y = THREE.MathUtils.randFloatSpread(Math.PI * 2);
              object.updateMatrix();
              return object;
            }}
            mesh={meshRef}
          >
            <instancedMesh
              args={[foliageNodes.Object_6.geometry, null!, count]}
            >
              <GrassMaterial baseMaterial={foliageMaterials.Foliage_Grass_B} />
            </instancedMesh>
          </Sampler>

          {/* Dandelions */}
          <Sampler
            count={count / 10}
            transform={({ position, normal, dummy: object }) => {
              const p = position.clone().multiplyScalar(1);
              let n = noise(...p.toArray());
              n = THREE.MathUtils.smootherstep(n, 0.0, 0.7);
              object.scale.setScalar(
                THREE.MathUtils.mapLinear(n, -1, 1, 0.2, 2)
              );
              object.position.copy(position);
              object.rotation.y = THREE.MathUtils.randFloatSpread(Math.PI * 2);
              object.updateMatrix();
              return object;
            }}
            mesh={meshRef}
          >
            <instancedMesh
              args={[foliageNodes.Object_18.geometry, null!, count / 10]}
            >
              <GrassMaterial baseMaterial={foliageMaterials.Foliage_Grass_F} />
            </instancedMesh>
          </Sampler>

          {/* Weeds */}
          <Sampler
            count={count / 10}
            transform={({ position, normal, dummy: object }) => {
              const p = position.clone().multiplyScalar(1);
              let n = noise(...p.toArray());
              n = THREE.MathUtils.smootherstep(n, 0.0, 0.7);
              object.scale.setScalar(
                THREE.MathUtils.mapLinear(n, -1, 1, 0.7, 1.5)
              );
              object.position.copy(position);
              object.rotation.y = THREE.MathUtils.randFloatSpread(Math.PI * 2);
              object.updateMatrix();
              return object;
            }}
            mesh={meshRef}
          >
            <instancedMesh
              args={[foliageNodes.Object_4.geometry, null!, count / 10]}
            >
              <GrassMaterial baseMaterial={foliageMaterials.Foilage_Grass_A} />
            </instancedMesh>
          </Sampler>
        </>
      )}
    </group>
  );
}
